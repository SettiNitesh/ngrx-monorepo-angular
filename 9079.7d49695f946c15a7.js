(self.webpackChunkmfe=self.webpackChunkmfe||[]).push([[1460,9079],{9079:(R,y,l)=>{l.r(y),l.d(y,{outputFromObservable:()=>O,outputToObservable:()=>m,pendingUntilEvent:()=>D,rxResource:()=>j,takeUntilDestroyed:()=>b,toObservable:()=>f,toSignal:()=>g,\u0275toObservableMicrotask:()=>h});var e=l(4119),a=l(4866),d=l(2778);function b(r){r||((0,e.assertInInjectionContext)(b),r=(0,e.inject)(e.DestroyRef));const t=new a.Observable(n=>r.onDestroy(n.next.bind(n)));return n=>n.pipe((0,d.takeUntil)(t))}class p{source;destroyed=!1;destroyRef=(0,e.inject)(e.DestroyRef);constructor(t){this.source=t,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(t){if(this.destroyed)throw new e.\u0275RuntimeError(953,!1);const n=this.source.pipe(b(this.destroyRef)).subscribe({next:o=>t(o)});return{unsubscribe:()=>n.unsubscribe()}}}function O(r,t){return new p(r)}function m(r){const t=(0,e.\u0275getOutputDestroyRef)(r);return new a.Observable(n=>{t?.onDestroy(()=>n.complete());const o=r.subscribe(u=>n.next(u));return()=>o.unsubscribe()})}function f(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),o=new a.ReplaySubject(1),u=(0,e.effect)(()=>{let s;try{s=r()}catch(c){return void(0,e.untracked)(()=>o.error(c))}(0,e.untracked)(()=>o.next(s))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{u.destroy(),o.complete()}),o.asObservable()}function h(r,t){!t?.injector&&(0,e.assertInInjectionContext)(f);const n=t?.injector??(0,e.inject)(e.Injector),o=new a.ReplaySubject(1),u=(0,e.\u0275microtaskEffect)(()=>{let s;try{s=r()}catch(c){return void(0,e.untracked)(()=>o.error(c))}(0,e.untracked)(()=>o.next(s))},{injector:n,manualCleanup:!0});return n.get(e.DestroyRef).onDestroy(()=>{u.destroy(),o.complete()}),o.asObservable()}function g(r,t){const n=!t?.manualCleanup;n&&!t?.injector&&(0,e.assertInInjectionContext)(g);const o=n?t?.injector?.get(e.DestroyRef)??(0,e.inject)(e.DestroyRef):null,u=function k(r=Object.is){return(t,n)=>1===t.kind&&1===n.kind&&r(t.value,n.value)}(t?.equal);let s;s=(0,e.signal)(t?.requireSync?{kind:0}:{kind:1,value:t?.initialValue},{equal:u});const c=r.subscribe({next:i=>s.set({kind:1,value:i}),error:i=>{if(t?.rejectErrors)throw i;s.set({kind:2,error:i})}});if(t?.requireSync&&0===s().kind)throw new e.\u0275RuntimeError(601,!1);return o?.onDestroy(c.unsubscribe.bind(c)),(0,e.computed)(()=>{const i=s();switch(i.kind){case 1:return i.value;case 2:throw i.error;case 0:throw new e.\u0275RuntimeError(601,!1)}},{equal:t?.equal})}function D(r){void 0===r&&((0,e.assertInInjectionContext)(D),r=(0,e.inject)(e.Injector));const t=r.get(e.PendingTasks);return n=>new a.Observable(o=>{const u=t.add();let s=!1;function c(){s||(u(),s=!0)}const i=n.subscribe({next:v=>{o.next(v),c()},complete:()=>{o.complete(),c()},error:v=>{o.error(v),c()}});return i.add(()=>{o.unsubscribe(),c()}),i})}function j(r){return r?.injector||(0,e.assertInInjectionContext)(j),(0,e.resource)({...r,loader:t=>{const n=new a.Subject;return t.abortSignal.addEventListener("abort",()=>n.next()),new Promise((o,u)=>{r.loader(t).pipe((0,d.take)(1),(0,d.takeUntil)(n)).subscribe({next:o,error:u,complete:()=>u(new Error("Resource completed before producing a value"))})})}})}}}]);